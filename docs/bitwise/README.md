## 231.2的幂

##### 题目描述

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

##### 示例一：
```
输入: 1
输出: true
解释: 20 = 1
```

##### 示例二：
```
输入: 16
输出: true
解释: 24 = 16
```

##### 示例三：
```
输入: 218
输出: false
```

##### 解题思路

若n=2<sup>x</sup>且x为自然数，则一定满足以下条件：
- 恒有n & (n - 1)
- n > 0

2^x | n     | n - 1   | n & (n - 1)
:-  | :-    | :-      | :-
2^0 | 0001  |0000     |0
2^1 | 0010  |0001     |0
2^2 | 0100  |0011     |0
2^3 | 1000  |0111     |0
... | ...   |...      |...

**代码**
```javascript
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    return n > 0 && (n & (n - 1)) === 0
};
```

------

## 338. 比特位计数

##### 题目描述

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

##### 示例一
```
输入: 2
输出: [0,1,1]
```

##### 示例二
```
输入: 5
输出: [0,1,1,2,1,2]
```

##### 解题思路

**动态规划——最高有效位**

nums|二进制|个数| 结果
:-  |:-    |:- | :-
0   | 0    | 0 |
1   | 01   | 1 | 2^0
2   | 10   | 1 | 2^1
3   | 0011 | 2 | nums[i - 2] + 1
4   | 0100 | 1 | 2^2
5   | 0101 | 2 | nums[i - 4] + 1
6   | 0110 | 2 | nums[i - 4] + 1
7   | 0111 | 3 | nums[i - 4] + 1
8   | 1000 | 1 | 2^3
9   | 1000 | 1 | nums[i - 8] + 1
10  | 1000 | 1 | nums[i - 8] + 1

- 如果 i&(i−1)=0，则令 highBit=i，更新当前的最高有效位。
- i 比 i−highBit 的「一比特数」多 1，由于是从小到大遍历每个数，因此遍历到 i 时，i−highBit 的「一比特数」已知，令bits[i]=bits[i−highBit]+1。

**代码**
```javascript
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
    const bits = new Array(num + 1).fill(0);
    let highBit = 0;
    for (let i = 1; i <= num; i++) {
        if ((i & (i - 1)) == 0) {
            highBit = i;
        }
        bits[i] = bits[i - highBit] + 1;
    }
    return bits;
};
```

------